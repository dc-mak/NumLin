metavar fc ::=
  {{ tex \mathit{[[fc]]} }} {{ com fractional capability variable }}


metavar x, g, a, b ::=
  {{ tex \mathit{[[x]]} }} {{ com expression variable }}


metavar k ::=
  {{ tex \mathit{[[k]]} }} {{ com integer variable }}


metavar el ::=
  {{ tex \mathit{[[el]]} }} {{ com array-element variable }}


grammar

  terminals {{ tex symb }} :: 'terminals_' ::=
    | \     ::  :: lambda    {{ tex \lambda       }}
    | 0     ::  :: product   {{ tex \otimes       }}
    | --o   ::  :: lollipop  {{ tex \multimap     }}
    | |-    ::  :: turnstile {{ tex \vdash        }}
    | mem   ::  :: member    {{ tex \in           }}
    | all   ::  :: all       {{ tex \forall       }}
    | Cap   ::  :: cap       {{ tex \textsf{Cap}  }}
    | Type  ::  :: type      {{ tex \textsf{Type} }}
    | !     ::  :: bang      {{ tex \: !          }}
    | ->    ::  :: arrow     {{ tex \rightarrow   }}
    | value ::  :: value


  f :: 'f_' ::=       {{ com fractional capability }}
    | fc  ::  :: Var  {{ com variable              }}
    | Z   ::  :: Zero {{ com zero                  }}
    | S f ::  :: Succ {{ com successor             }}


  t :: 't_' ::=                    {{ com linear type               }}
    | unit         ::   :: Unit    {{ com unit                      }}
    | bool         ::   :: Bool    {{ com boolean (true/false)      }}
    | int          ::   :: Int     {{ com 63-bit integers           }}
    | elt          ::   :: Elt     {{ com array element             }}
    | f arr        ::   :: Array   {{ com arrays                    }}
    | f mat        ::   :: Matrix  {{ com matrices                  }}
    | ! t          ::   :: Bang    {{ com multiple-use type         }}
    | all fc . t   ::   :: Gen     (+ bind fc in t                  +)
                                   {{ com frac. cap. generalisation }}
    | t 0 t'       ::   :: Pair    {{ com pair                      }}
    | t --o t'     ::   :: Lolly   {{ com linear function           }}
    | t { f / fc } :: M :: Sub     {{ com substitution              }}
    | ( t )        :: S :: Paren   {{ com parentheses               }}


  e :: 'e_' ::=                                       {{ com expression                }}
    | p                           ::   :: Prim        {{ com primitives                }}
    | x                           ::   :: Var         {{ com variable                  }}
    | let x = e in e'             ::   :: Let         (+ bind x in e'                  +)
                                                      {{ com let binding               }}
    | ( )                         ::   :: Unit_Intro  {{ com unit introduction         }}
    | let ( ) = e in e'           ::   :: Unit_Elim   {{ com unit elimination          }}
    | true                        ::   :: Bool_True   {{ com true                      }}
    | false                       ::   :: Bool_False  {{ com false                     }}
    | if e then e1 else e2        ::   :: Bool_Elim   {{ com if                        }}
    | k                           ::   :: Int_Intro   {{ com integer                   }}
    | el                          ::   :: Elt_Intro   {{ com array element             }}
    | Many e                      ::   :: Bang_Intro  {{ com !-introduction            }}
    | let Many x = e in e'        ::   :: Bang_Elim   {{ com !-elimination             }}
    | fun fc -> e                 ::   :: Gen         {{ com frac. cap. abstraction    }}
    | e [ f ]                     ::   :: Spc         {{ com frac. cap. specialisation }}
    | ( e , e' )                  ::   :: Pair_Intro  {{ com pair introduction         }}
    | let ( a , b ) = e in e'     ::   :: Pair_Elim   (+ bind a union b in e'          +)
                                                      {{ com pair elimination          }}
    | fun x : t -> e              ::   :: Lambda      (+ bind x in e                   +)
                                                      {{ com abstraction               }}
    | e e'                        ::   :: App         {{ com application               }}
    | fix ( g , x : t , e : t' )  ::   :: Fix         (+ bind g union x in e           +)
                                                      {{ com fixpoint                  }}
%   | ( e )                       :: S :: Paren       {{ com parentheses               }}


   p :: 'p_' ::=                {{ com primitive                                   }}
     | set      ::  :: Set      {{ com array index assignment                      }}
     | get      ::  :: Get      {{ com array indexing                              }}
     | ( + )    ::  :: Int_Add  {{ com integer addition                            }}
     | ( - )    ::  :: Int_Sub  {{ com integer subtraction                         }}
     | ( * )    ::  :: Int_Mul  {{ com integer multiplication                      }}
     | ( / )    ::  :: Int_Div  {{ com integer division                            }}
     | ( = )    ::  :: Int_Eq   {{ com integer equality                            }}
     | ( < )    ::  :: Int_Lt   {{ com integer less-than                           }}
     | ( +. )   ::  :: Elt_Add  {{ com element addition                            }}
     | ( -. )   ::  :: Elt_Sub  {{ com element subtraction                         }}
     | ( *. )   ::  :: Elt_Mul  {{ com element multiplication                      }}
     | ( /. )   ::  :: Elt_Div  {{ com element division                            }}
     | ( =. )   ::  :: Elt_Eq   {{ com element equality                            }}
     | ( <. )   ::  :: Elt_Lt   {{ com element less-than                           }}
     | not      ::  :: Not      {{ com boolean negation                            }}
     | share    ::  :: Share    {{ com share array                                 }}
     | unshare  ::  :: Unshare  {{ com unshare array                               }}
     | free     ::  :: Free     {{ com free arrary                                 }}
     | array    ::  :: Array    {{ com Owl:  make array                            }}
     | copy     ::  :: Copy     {{ com Owl:  copy array                            }}
     | sin      ::  :: Sin      {{ com Owl:  map sine over array                   }}
     | hypot    ::  :: Hypot    {{ com Owl:  $x_i := \sqrt{x_i^2 + y_i^2}$         }}
     | asum     ::  :: Asum     {{ com BLAS: $\sum_i | x_i |$                      }}
     | axpy     ::  :: Axpy     {{ com BLAS: $x := \alpha x + y$                   }}
     | dot      ::  :: Dot      {{ com BLAS: $x \cdot y$                           }}
     | rotmg    ::  :: Rotmg    {{ com BLAS: see its docs                          }}
     | scal     ::  :: Scal     {{ com BLAS: $x := \alpha x$                       }}
     | amax     ::  :: Amax     {{ com BLAS: $\textrm{argmax}\,i:\,x_i$            }}
     | setM     ::  :: SetM     {{ com matrix index assignment                     }}
     | getM     ::  :: GetM     {{ com matrix indexing                             }}
     | shareM   ::  :: ShareM   {{ com share matrix                                }}
     | unshareM ::  :: UnshareM {{ com unshare matrix                              }}
     | freeM    ::  :: FreeM    {{ com free matrix                                 }}
     | matrix   ::  :: Matrix   {{ com Owl:  make matrix                           }}
     | copyM    ::  :: CopyM    {{ com Owl:  copy matrix                           }}
     | copyM_to ::  :: CopyM_to {{ com Owl:  copy matrix onto another              }}
                                {{ tex \textbf{copyM\_to}                          }}
     | gemm     ::  :: Gemm     {{ com BLAS: $C := \alpha A^{T?} B^{T?} + \beta C$ }}
     | symm     ::  :: Symm     {{ com BLAS: $C := \alpha A B + \beta C$           }}
     | posv     ::  :: Posv     {{ com BLAS: Cholesky decomp. and solve            }}
     | potrs    ::  :: Potrs    {{ com BLAS: solve with given Cholesky             }}


  T {{ tex \Theta }} :: 'T_' ::= {{ com fractional capability environment }}
    | nil    ::   :: Nil {{ tex \cdot }}
    | T , fc ::   :: Ext


  G {{ tex \Gamma }} :: 'G_' ::= {{ com linear types environment }}
    | nil       ::   :: Nil {{ tex \cdot }}
    | G , x : t ::   :: Ext
    | G , G'    ::   :: Split


  D {{ tex \Delta }} :: 'D_' ::= {{ com linear types environment }}
    | nil       ::  :: Nil    {{ tex \cdot }}
    | D , x : t ::  :: Ext


defns
  Well_Formed :: 'WF_' ::=


  defn
  T |- f Cap :: ::Cap_:: 'Cap_' {{ com Valid fractional capabilities }} by


    fc mem T
    ----------- :: Var
    T |- fc Cap


    ---------- :: Zero
    T |- Z Cap


    T |- f Cap
    ------------ :: Succ
    T |- S f Cap


  defn
  T |- t Type :: ::Type_:: 'Type_' {{ com Valid types }} by


    -------------- :: Unit
    T |- unit Type


    -------------- :: Bool
    T |- bool Type


    ------------- :: Int
    T |- int Type


    ------------- :: Elt
    T |- elt Type


    T |- f Cap
    --------------- :: Array
    T |- f arr Type


    T |- t Type
    ------------- :: Bang
    T |- ! t Type


    T, fc |- t Type
    ------------------------ :: Gen
    T     |- all fc . t Type


    T |- t Type
    T |- t' Type
    ---------------- :: Pair
    T |- t 0 t' Type


    T |- t Type
    T |- t' Type
    ---------------- :: Lolly
    T |- t --o t' Type


defns
  Values :: 'Val_' ::=


  defn
  value ( e ) :: ::Value_:: '' {{ com Value restriction for !-introduction }} by

  ----------- :: Prim
  value ( p )

  ------------ :: Unit_Intro
  value ( () )

  -------------- :: Bool_True
  value ( true )

  --------------- :: Bool_False
  value ( false )

  ----------- :: Int_Intro
  value ( k )

  ------------ :: Elt_Intro
  value ( el )

  ----------- :: Var
  value ( x )

  ------------------------------- :: Fix
  value ( fix ( g , x : t , e : t' ) )

  ------------------------ :: Lambda
  value ( fun x : t -> e )

  value ( e )
  --------------------- :: Gen
  value ( fun fc -> e )

  value ( e )
  ------------------ :: Spc
  value ( e [ fc ] )

  value ( e )
  ---------------- :: Bang_Intro
  value ( Many e )

  value ( e1 )
  value ( e2 )
  --------------------- :: Pair_Intro
  value ( ( e1 , e2 ) )

defns
  Types :: 'Ty_' ::=


  defn
  T ; D ; G |- e : t :: ::Type_:: '' {{ com Typing rules for expressions }} by


    ---------------------- :: Var_Lin
    T ; D ; nil, x : t |- x : t


    x : t mem D
    ---------------------- :: Var
    T ; D ; nil |- x : t


    T ; D ; G          |- e  : t
    T ; D ; G' , x : t |- e' : t'
    -------------------------------------- :: Let
    T ; D ; G , G' |- let x = e in e' : t'


    --------------------------- :: Unit_Intro
    T ; D ; nil |- ( ) : unit


    T ; D ; nil |- e  : unit
    T ; D ; G   |- e' : t
    ---------------------------------- :: Unit_Elim
    T ; D ; G |- let ( ) = e in e' : t


    ---------------------------- :: Bool_True
    T ; D ; nil |- true : ! bool


    ----------------------------- :: Bool_False
    T ; D ; nil |- false : ! bool


    T ; D ; G  |- e  : bool
    T ; D ; G' |- e1 : t'
    T ; D ; G' |- e2 : t'
    ------------------------------------------ :: Bool_Elim
    T ; D ; G , G' |- if e then e1 else e2 : t


    ------------------------ :: Int_Intro
    T ; D ; nil |- k : ! int


    ------------------------- :: Elt_Intro
    T ; D ; nil |- el : ! elt


    value ( e )
    T ; D ; nil |- e : t
    --------------------------- :: Bang_Intro
    T ; D ; nil |- Many e : ! t


    T ; D ; G          |- e : ! t
    T ; D , x : t ; G' |- e' : t'
    ------------------------------------------ :: Bang_Elim
    T ; D ; G, G' |- let Many x = e in e' : t'


    T ; D ; G  |- e  : t
    T ; D ; G' |- e' : t'
    ------------------------------------- :: Pair_Intro
    T ; D ; G , G' |- ( e , e' ) : t 0 t'


    T ; D ; G                  |- e12 : t1 0 t2
    T ; D ; G', a : t1, b : t2 |- e : t
    ---------------------------------------------- :: Pair_Elim
    T ; D ; G, G' |- let ( a , b ) = e12 in  e : t


    T                 |- t' Type
    T ; D ; G, x : t' |- e : t
    --------------------------------------- :: Lambda
    T ; D ; G |- fun x : t' -> e : t' --o t


    T ; D ; G  |- e  : t' --o t
    T ; D ; G' |- e' : t'
    --------------------------- :: App
    T ; D ; G, G' |- e e' : t


    T , fc ; D ; G |- e : t
    ------------------------------------- :: Gen
    T ; D ; G |- fun fc -> e : all fc . t


    T |- f Cap
    T ; D ; G |- e : all fc . t
    ----------------------------------- :: Spc
    T ; D ; G |- e [ f ] : t { f / fc }


    T ; D , g : t --o t'  ; nil, x : t |- e : t'
    ---------------------------------------------------------- :: Fix
    T ; D ; nil |- fix ( g , x : t , e : t' ) : ! ( t --o t' )

grammar

  formula :: 'formula_' ::=
    | judgement      ::  :: judgement
    | x : t mem D    ::  :: xtD
    | x : t mem G    ::  :: xtG
    | fc    mem T    ::  :: fcT
    | value ( e  )   ::  :: valE


% vim: sw=2 sts=2
