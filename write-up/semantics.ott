metavar fc ::=
  {{ tex \mathit{[[fc]]} }} {{ com fractional capability variable }}


metavar x, g, a, b ::=
  {{ tex \mathit{[[x]]} }} {{ com expression variable }}


metavar k ::=
  {{ tex \mathit{[[k]]} }} {{ com integer variable }}


metavar el ::=
  {{ tex \mathit{[[el]]} }} {{ com array-element variable }}


grammar

  terminals {{ tex symb }} :: 'terminals_' ::=
    | \    ::  :: lambda    {{ tex \lambda       }}
    | 0    ::  :: product   {{ tex \otimes       }}
    | --o  ::  :: lollipop  {{ tex \multimap     }}
    | |-   ::  :: turnstile {{ tex \vdash        }}
    | mem  ::  :: member    {{ tex \in           }}
    | all  ::  :: all       {{ tex \forall       }}
    | Cap  ::  :: cap       {{ tex \textsf{Cap}  }}
    | Type ::  :: type      {{ tex \textsf{Type} }}
    | !    ::  :: bang      {{ tex \: !          }}
    | ->   ::  :: arrow     {{ tex \rightarrow   }}
    | !=   ::  :: neq       {{ tex \neq          }}


  f :: 'f_' ::=       {{ com fractional capability }}
    | fc  ::  :: Var  {{ com variable              }}
    | Z   ::  :: Zero {{ com zero                  }}
    | S f ::  :: Succ {{ com successor             }}


  t :: 't_' ::=                    {{ com linear type               }}
    | unit         ::   :: Unit    {{ com unit                      }}
    | bool         ::   :: Bool    {{ com boolean (true/false)      }}
    | int          ::   :: Int     {{ com 63-bit integers           }}
    | elt          ::   :: Elt     {{ com array element             }}
    | f arr        ::   :: Array   {{ com arrays                    }}
    | ! t          ::   :: Bang    {{ com multiple-use type         }}
    | all fc . t   ::   :: Gen     (+ bind fc in t                  +)
                                   {{ com frac. cap. generalisation }}
    | t 0 t'       ::   :: Pair    {{ com pair                      }}
    | t --o t'     ::   :: Lolly   {{ com linear function           }}
    | t { f / fc } :: M :: Sub     {{ com substitution              }}
%   | ( t )        :: S :: Paren   {{ com parentheses               }}


  e :: 'e_' ::=                                   {{ com expression                            }}
    | p                       ::   :: Prim        {{ com primitives (arithmetic, L1 BLAS, Owl) }}
    | x                       ::   :: Var         {{ com variable                              }}
    | ( )                     ::   :: Unit_Intro  {{ com unit introduction                     }}
    | true                    ::   :: Bool_True   {{ com true (boolean introduction)           }}
    | false                   ::   :: Bool_False  {{ com false (boolean introduction)          }}
    | if e then e1 else e2    ::   :: Bool_Elim   {{ com if (boolean elimination)              }}
    | k                       ::   :: Int_Intro   {{ com integer                               }}
    | el                      ::   :: Elt_Intro   {{ com array element                         }}
    | many e                  ::   :: Bang_Intro  {{ com packing-up a non-linear value         }}
    | let many x = e in e'    ::   :: Bang_Elim   {{ com using a non-linear value              }}
    | fun fc -> e             ::   :: Gen         {{ com frac. cap. abstraction                }}
    | e [ f ]                 ::   :: Spc         {{ com frac. cap. specialisation             }}
    | ( e , e' )              ::   :: Pair_Intro  {{ com pair introduction                     }}
    | let ( a , b ) = e in e' ::   :: Pair_Elim   (+ bind a union b in e'                      +)
                                                  {{ com pair elimination                      }}
    | fun x : t -> e          ::   :: Lambda      (+ bind x in e                               +)
                                                  {{ com abstraction                           }}
    | e e'                    ::   :: App         {{ com application                           }}
%   | ( e )                   :: S :: Paren       {{ com parentheses                           }}


   p :: 'p_' ::=              {{ com primitive                             }}
     | fix     ::  :: Fix     {{ com fixpoint                              }}
     | set     ::  :: Set     {{ com array index assignment                }}
     | get     ::  :: Get     {{ com array indexing                        }}
     | ( + )   ::  :: Int_Add {{ com integer addition                      }}
     | ( - )   ::  :: Int_Sub {{ com integer subtraction                   }}
     | ( * )   ::  :: Int_Mul {{ com integer multiplication                }}
     | ( / )   ::  :: Int_Div {{ com integer division                      }}
     | ( = )   ::  :: Int_Eq  {{ com integer equality                      }}
     | ( < )   ::  :: Int_Lt  {{ com integer less-than                     }}
     | ( +. )  ::  :: Elt_Add {{ com element addition                      }}
     | ( -. )  ::  :: Elt_Sub {{ com element subtraction                   }}
     | ( *. )  ::  :: Elt_Mul {{ com element multiplication                }}
     | ( /. )  ::  :: Elt_Div {{ com element division                      }}
     | ( =. )  ::  :: Elt_Eq  {{ com element equality                      }}
     | ( <. )  ::  :: Elt_Lt  {{ com element comparsion (less-than)        }}
     | ( && )  ::  :: And     {{ com boolean conjuction                    }}
     | ( || )  ::  :: Or      {{ com boolean disjunction                   }}
     | not     ::  :: Not     {{ com boolean negation                      }}
     | share   ::  :: Share   {{ com share array                           }}
     | unshare ::  :: Unshare {{ com unshare array                         }}
     | free    ::  :: Free    {{ com free arrary                           }}
     | array   ::  :: Array   {{ com Owl:  make array                      }}
     | copy    ::  :: Copy    {{ com Owl:  copy array                      }}
     | sin     ::  :: Sin     {{ com Owl:  sine of all elements in array   }}
     | hypot   ::  :: Hypot   {{ com Owl:  $x_i := \sqrt{x_i^2 + y_i^2}$   }}
     | mapi    ::  :: Mapi    {{ com Owl:  $x_i := f (i,x_i)$              }}
     | asum    ::  :: Asum    {{ com BLAS: $\sum_i | x_i |$                }}
     | axpy    ::  :: Axpy    {{ com BLAS: $x := \alpha x + y$             }}
     | dot     ::  :: Dot     {{ com BLAS: $x \cdot y$                     }}
     | rotmg   ::  :: Rotmg   {{ com BLAS: gen. mod. Givens rotation       }}
     | scal    ::  :: Scal    {{ com BLAS: $x := \alpha x$                 }}
     | amax    ::  :: Amax    {{ com BLAS: index of maximum absolute value }}


  T {{ tex \Theta }} :: 'T_' ::= {{ com fractional capability environment }}
    | nil    ::   :: Nil {{ tex \cdot }}
    | T , fc ::   :: Ext


  G {{ tex \Gamma }} :: 'G_' ::= {{ com linear types environment }}
    | nil       ::   :: Nil {{ tex \cdot }}
    | G , x : t ::   :: Ext
    | G , G'    ::   :: Split


  D {{ tex \Delta }} :: 'D_' ::= {{ com linear types environment }}
    | nil       ::  :: Nil    {{ tex \cdot }}
    | D , x : t ::  :: Ext


defns
  Well_Formed :: 'WF_' ::=


  defn
  T |- f Cap :: ::Cap_:: 'Cap_' {{ com Valid fractional capabilities }} by


    fc mem T
    ----------- :: Var
    T |- fc Cap


    ---------- :: Zero
    T |- Z Cap


    T |- f Cap
    ------------ :: Succ
    T |- S f Cap


  defn
  T |- t Type :: ::Type_:: 'Type_' {{ com Valid types }} by


    -------------- :: Unit
    T |- unit Type


    -------------- :: Bool
    T |- bool Type


    ------------- :: Int
    T |- int Type


    ------------- :: Elt
    T |- elt Type


    T |- f Cap
    --------------- :: Array
    T |- f arr Type


    T |- t Type
    ------------- :: Bang
    T |- ! t Type


    T, fc |- t Type
    ------------------------ :: Gen
    T     |- all fc . t Type


    T |- t Type
    T |- t' Type
    ---------------- :: Pair
    T |- t 0 t' Type


    T |- t Type
    T |- t' Type
    ---------------- :: Lolly
    T |- t --o t' Type


defns
  Types :: 'Ty_' ::=


  defn
  T ; D ; G |- e : t :: ::Type_:: '' {{ com Tying rules for expressions (no primitives yet) }} by


    ---------------------- :: Var_Lin
    T ; D ; nil, x : t |- x : t


    x : t mem D
    ---------------------- :: Var
    T ; D ; nil |- x : t


    --------------------------- :: Unit_Intro
    T ; D ; nil |- ( ) : ! unit


    ---------------------------- :: Bool_True
    T ; D ; nil |- true : ! bool


    ----------------------------- :: Bool_False
    T ; D ; nil |- false : ! bool


    T ; D ; G  |- e  : bool
    T ; D ; G' |- e1 : t'
    T ; D ; G' |- e2 : t'
    ------------------------------------------ :: Bool_Elim
    T ; D ; G , G' |- if e then e1 else e2 : t


    ------------------------ :: Int_Intro
    T ; D ; nil |- k : ! int


    ------------------------- :: Elt_Intro
    T ; D ; nil |- el : ! elt


    t != f arr
    T ; D ; nil |- e : t
    --------------------------- :: Bang_Intro
    T ; D ; nil |- many e : ! t


    T ; D ; G          |- e : ! t
    T ; D , x : t ; G' |- e' : t'
    ------------------------------------------ :: Bang_Elim
    T ; D ; G, G' |- let many x = e in e' : t'


    T ; D ; G  |- e  : t
    T ; D ; G' |- e' : t'
    ------------------------------------- :: Pair_Intro
    T ; D ; G , G' |- ( e , e' ) : t 0 t'


    T ; D ; G                  |- e12 : t1 0 t2
    T ; D ; G', a : t1, b : t2 |- e : t
    ---------------------------------------------- :: Pair_Elim
    T ; D ; G, G' |- let ( a , b ) = e12 in  e : t


    T                 |- t' Type
    T ; D ; G, x : t' |- e : t
    --------------------------------------- :: Lambda
    T ; D ; G |- fun x : t' -> e : t' --o t


    T ; D ; G  |- e  : t' --o t
    T ; D ; G' |- e' : t'
    --------------------------- :: App
    T ; D ; G, G' |- e e' : t


    T , fc ; D ; G |- e : t
    ------------------------------------- :: Gen
    T ; D ; G |- fun fc -> e : all fc . t


    T |- f Cap
    T ; D ; G |- e : all fc . t
    ----------------------------------- :: Spc
    T ; D ; G |- e [ f ] : t { f / fc }


grammar

  formula :: 'formula_' ::=
    | judgement   ::  :: judgement
    | x : t mem D ::  :: xtD
    | x : t mem G ::  :: xtG
    | fc    mem T ::  :: fcT
    | t != t'    ::  :: t_neq_t


% vim: sw=2 sts=2
