\section{Implementation}\label{sec:implementation}

Talk about how you implemented \lang\ and the general
architecture. Talk about how simple everything is, and also
about how implementing inference for fractions is.

\subsection{Implementation Strategy}

\lang\ transpiles to OCaml and its implementation follows the structure of a
typical domain-specific language (DSL) compiler. Although \lang's current
implementation is not as an embedded DSL, its the general design is simple enough
to adapt to being so and also to target other languages.

Alongside the transpiler, a `Read-Check-Translate' loop, benchmarking program
and a test suite are included in the artifacts accompanying this paper.

\begin{enumerate}

    \item \textbf{Parsing}. A generated, LR(1) parser parses a text file into a
        syntax tree. In general, this part will vary for different languages
        and can also be dealt with using combinators or syntax-extensions (the
        EDSL approach) if the host language offers such support.

    \item \textbf{Desugaring}. The syntax tree is then desugared into a
        smaller, more concise, abstract syntax tree. This allows for the type
        checker to be simpler to specify and easier to implement.

    \item \textbf{Matrix Expressions} are also desugared into the abstract
        syntax tree through some simple pattern-matching.

    \item \textbf{Type checking}. The abstract syntax tree is explicitly typed,
        with some inference to make writing typical programs more convenient.

    \item \textbf{Code Generation}. The abstract syntax tree is translated into
        OCaml, with a few `optimisations' to produce more readable code. This
        process is type-preserving: \lang's type system is embedded into
        OCaml's (Figure~\ref{fig:type_grammar}), and so the OCaml type checker
        acts as a sanity check on the generated code.

\end{enumerate}

A very pleasant way to use \lang\ is to have the build system generate code at
\emph{compile-time} and then have the generated code be used by other modules
like normal OCaml functions. This makes it possible and even easy to use \lang\
alongside existing OCaml libraries; in fact, this is exactly how the
benchmarking program and test-suite use code written in \lang.

\subsubsection{Desugaring, Matrix Expressions and Type Checking}\label{subsubsec:initial}

Desugaring is conventional, outlined in Figure~\ref{fig:lang_desugar}.  Matrix
expression are translated into BLAS/ LAPACK calls via purely syntactic
pattern-matching, outlined in Figure~\ref{fig:lang_matexp}. Type checking is
mostly standard for a linearly typed language, with the exception of fractional
permission inference.  Because all functions must have their argument types
explicitly annotated, inferring the correct fraction at a call-site is simply a
matter of unification.

\textsc{What more can/should we say here?}

\begin{figure}[t]
\begin{center}
\[\def\arraystretch{1.3}
    \begin{array}{rcl}
    \mathbf{let\ } v \leftarrow x[e]\ \mathbf{in\ } e &
    \Rightarrow &
    \mathbf{let\ } (x, !v)\ = x[e]\ \mathbf{in\ } e \qquad \textrm{(similarly for matrices)}
\\
    \mathbf{let\ } x_2 \leftarrow \mathbf{new}\ [|\ x_1\ |]\ \mathbf{in\ } e &
    \Rightarrow &
    \mathbf{let\ } (x_1, x_2)\ = \mathbf{copyM\ } \_\ x_1\ \mathbf{in\ } e
\\
    \mathbf{let\ } x_2 \leftarrow [|\ x_1\ |]\ \mathbf{in\ } e &
    \Rightarrow &
    \mathbf{let\ } (x_1, x_2)\ = \mathbf{copyM\_to\ } \_\  x_1\ x_2\ \mathbf{in\ } e
    \end{array}
\]
\[
    M ::= X\ \mid\ X^T\ \mid\ \textrm{sym}( X )
\]
\end{center}
\begin{align*}
% new
    \mathbf{let\ } &Y \leftarrow \mathbf{new}\ (n, k)\ [|\ \alpha M_1 M_2 \ |]\ \mathbf{in\ } e
    \Rightarrow \\
    & \mathbf{let\ } Y\ = \mathbf{matrix\ } n\ k\ \mathbf{in}
    \ \mathbf{let\ } Y \leftarrow [|\ \alpha M_1 M_2 + 0Y\ |]\ \mathbf{in\ } e
\\[0.1\baselineskip]
%syrk
    \mathbf{let\ } &Y \leftarrow [|\ \alpha X X^T + \beta Y\ |]\ \mathbf{in\ } e
    \Rightarrow \\
    & \mathbf{let\ } (X,Y)\ = \mathbf{syrk\ } \mathbf{false}
    \ \alpha\ \_\ X\ \beta\ Y\ \mathbf{in\ } e
\\[0.1\baselineskip]
    \mathbf{let\ } &Y \leftarrow [|\ \alpha X^T X + \beta Y\ |]\ \mathbf{in\ } e
    \Rightarrow \\
    & \mathbf{let\ } (X,Y)\ = \mathbf{syrk\ } \mathbf{true}
    \ \alpha\ \_\ X\ \beta\ Y\ \mathbf{in\ } e
%symm
\\[0.1\baselineskip]
    \mathbf{let\ } &Y \leftarrow\ [|\ \alpha\,\textrm{sym}(X_1)\,X_2 + \beta Y\ |]\ \mathbf{in\ } e
    \Rightarrow \\
    & \mathbf{let\ } ((X_1,X_2),Y)\ = \mathbf{symm\ } \mathbf{false}
        \ \alpha\ \_ \ X_1 \_\ X_2\ \beta\ Y\ \mathbf{in\ } e
\\[0.1\baselineskip]
    \mathbf{let\ } &Y \leftarrow\ [|\ \alpha\,X_2\,\textrm{sym}(X_1) + \beta Y\ |]\ \mathbf{in\ } e
    \Rightarrow \\
    & \mathbf{let\ } ((X_1,X_2),Y)\ = \mathbf{symm\ } \mathbf{false}
        \ \alpha\ \_ \ X_1 \_\ X_2\ \beta\ Y\ \mathbf{in\ } e
\\[0.1\baselineskip]
%gemm
    \mathbf{let\ } &Y \leftarrow [|\ \alpha X_1^{T?} X_2^{T?} + \beta Y\ |]\ \mathbf{in\ } e
    \Rightarrow \\
    & \mathbf{let\ } ((X_1,X_2),Y)\ =\ \mathbf{gemm\ } \alpha
        \ \_\ \left(X_1, \substack{\mathbf{true}\\\mathbf{false}}\right)
        \ \_\ \left(X_2, \substack{\mathbf{true}\\\mathbf{false}}\right)
        \ \beta\ Y\ \mathbf{in\ } e
\end{align*}

\caption{Purely syntactic pattern-matching translations of
    matrix expressions.}\label{fig:lang_matexp}
\end{figure}

\subsubsection{Code Generation} is a straightforward mapping from \lang's core
constructs to high-level OCaml ones. We embed \lang's type- and term-
constructors into OCaml as a sanity check on the output
(Figure~\ref{fig:type_grammar}).

\begin{figure}[t]
    \centering
    \begin{minipage}{.3\textwidth}
        \centering
        \begin{grammar}
            <f> ::= `'
            \alt <fc>
            \alt `Z'
            \alt `S' <f>

            <t> ::= `'
            \alt `unit'
            \alt `bool'
            \alt `int'
            \alt `elt'
            \alt <f> `arr'
            \alt <f> `mat'
            \alt `!' <t>
            \alt \synt{$\forall$} <fc.> <t>
            \alt <t> \lit{$\otimes$} \synt{$t'$}
            \alt <t> \lit{$\multimap$} \synt{$t'$}
        \end{grammar}
    \end{minipage}
    \begin{minipage}{.3\textwidth}
        \centering
        \begin{minted}[fontsize=\small]{ocaml}
module Arr =
  Owl.Dense.Ndarray.D

type z = Z
type 'a s = Succ

type 'a arr =
  A of Arr.arr
  [@@unboxed]

type 'a mat =
  M of Arr.arr
  [@@unboxed]

type 'a bang =
  Many of 'a
  [@@unboxed]
        \end{minted}
    \end{minipage}
    \begin{minipage}{.3\textwidth}
        \begin{align*}
            [\![ f\!c ]\!] &= \texttt{'fc} \\
            [\![ \textbf{Z} ]\!] &= \texttt{z}\\
            [\![ \textbf{S} \, f ]\!] &= [\![ f ]\!]\, \texttt{s}\\
            [\![ \textbf{unit} ]\!] &= \texttt{unit}\\
            [\![ \textbf{bool} ]\!] &= \texttt{bool}\\
            [\![ \textbf{int} ]\!] &= \texttt{int}\\
            [\![ \textbf{elt} ]\!] &= \texttt{float}\\
            [\![ f\, \textbf{arr} ]\!] &= [\![ f ]\!]\, \texttt{arr}\\
            [\![ f\, \textbf{mat} ]\!] &= [\![ f ]\!]\, \texttt{mat}\\
            [\![ \textbf{!} \, t ]\!] &= [\![ t ]\!]\, \texttt{bang}\\
            [\![ \forall f\!c.\, t ]\!] &= [\![ t ]\!]\\
            [\![ t \otimes t' ]\!] &= [\![ t ]\!] \texttt{*} [\![ t' ]\!]\\
            [\![ t \multimap t' ]\!] &= [\![ t ]\!] \rightarrow [\![ t' ]\!]
        \end{align*}
    \end{minipage}
    \caption{\lang's type grammar (left) and its embedding into OCaml
        (right).}\label{fig:type_grammar}
\end{figure}

This is also useful when using \lang\ from within OCaml; for example, we can
use existing tools to inspect the type of the function we are using
(Figure~\ref{fig:build}). It is worth reiterating that only the type- and term-
constructors are translated into OCaml, \lang's precise control over linearity
and aliasing are not brought over.

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{impl_build}
    \caption{Using \lang\ functions from OCaml.}\label{fig:build}
\end{figure}

We actually use this fact to our advantage to clean up the output OCaml by
removing what would otherwise be redundant re-bindings.  Combined with a
code-formatter, the resulting code is not obviously correct and exactly what an
expert would intend to write by hand, but now with the guarantees and safety of
\lang\ behind it. A small example is shown in Figure~\ref{fig:ocaml_sumarray},
a larger one in Figure~\ref{fig:ocaml_kalman}.

\begin{figure}[tp]
    \centering
    \begin{minted}[fontsize=\small]{ocaml}
let rec f i n x0 row =
  if Prim.extract @@ Prim.eqI i n then (row, x0)
  else
    let row, x1 = Prim.get row i in
    f (Prim.addI i (Many 1)) n (Prim.addE x0 x1) row
in
f
    \end{minted}
    \caption{Recursive OCaml function for a summing over an array, generated (at
        \emph{compile time}) from the code in Figure~\ref{fig:lang_sumarray},
        passed through \texttt{ocamlformat} for presentation.}\label{fig:ocaml_sumarray}
\end{figure}

\subsection{Performance Metrics}

Here, evaluate the performance of the examples from the second
section.  Compare with your C implementations, and perhaps as well as
the straightforward math transcribed into (Matlab/R/Numpy?).

\begin{figure}[t]
    \centering
    \input{timings.tex}
    \caption{Comparison of execution times (error bars are present but quite
        small). Small matrices and timings $n \le 5^3$ were micro-benchmarked
        with the Core\_bench library. Larger ones used Unix's
        \texttt{getrusage} functionality, sandwiched between calls to
        \highl{Gc.full_major} for the OCaml implementations.}\label{fig:timings}
\end{figure}

